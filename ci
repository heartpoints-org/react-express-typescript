#!/usr/bin/env bash

string:isEmpty() { local possiblyEmptyString=$1
    [ -z "${possiblyEmptyString}" ]
}

string:notEmpty() { local possiblyEmptyString=$1
    ! $(string:isEmpty "${possiblyEmptyString}")
}

log:info() { local args=$@
    echo $@
}

log:warn() { local args=$@
    echo "WARN: $@"
}

log:error() { local args=$@
    echo "ERROR: $@"
}

bash:command:exists() { local commandName=$1
    command -v "${commandName}" > /dev/null
}

bash:command:doesNotExist() { local commandName=$1
    ! bash:command:exists ${commandName}
}

log:warningAboutRootPassword() {
    log:warn "You may need to enter your root password. If you see a long pause, hit enter and follow prompts..."
}

brew:install:brewItself() {
    set -e
    if brew:notInstalled; then
        log:info "downloading brew..."
        log:warningAboutRootPassword
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    fi
}

brew:notInstalled() {
    bash:command:doesNotExist "brew"
}

brew:run() { local args=$@
    set -e
    brew:install:brewItself
    brew ${args}
}

brew:install() { local packageNames=$@
    brew:run install ${packageNames}
}

brew:tap() { local tapName=$1
    brew:run tap ${tapName}
}

brew:cask:notInstalled() {
    brew:notInstalled || ! brew cask > /dev/null
}

brew:cask:install:brewCaskItself() {
    if brew:cask:notInstalled; then
        log:info "Installing brew cask..."
        brew:tap caskroom/cask
    fi
}

brew:cask() { local args=$@
    set -e
    brew:cask:install:brewCaskItself
    brew:run cask ${args}
}

brew:cask:install() { local caskName=$1
    brew:cask install ${caskName}
}

brew:cask:uninstall() { local caskName=$1
    brew:cask uninstall ${caskName} -f
}

virtualbox:uninstall() {
    brew:cask:uninstall virtualbox
}

log:warningAboutMacOSXSecurityPrompt() {
    log:warn "On Mac OSX, this operation may be blocked by a security warning. If it is, please cancel and retry the operation after setting security preferences."
}

virtualbox:install() {
    set -e
    if bash:command:doesNotExist virtualbox; then
        log:warningAboutRootPassword
        log:warningAboutMacOSXSecurityPrompt
        brew:cask:install virtualbox
    fi
}

docker:machine:install() {
    set -e
    if bash:command:doesNotExist "docker-machine"; then
        virtualbox:install
        docker:install
        base=https://github.com/docker/machine/releases/download/v0.14.0 &&
            curl -L $base/docker-machine-$(uname -s)-$(uname -m) >/usr/local/bin/docker-machine &&
            chmod +x /usr/local/bin/docker-machine
    fi
}

docker:machine:uninstall() {
    rm -f /usr/local/bin/docker-machine
}

docker:machine() { local args=$@
    docker:machine:install
    docker-machine ${args}
}

docker:machine:host:name() {
    echo "default"
}

docker:machine:host:existsWith() { local filterArgs=$@
   string:notEmpty "$(docker:machine ls --quiet $filterArgs)"
}

docker:machine:host:isDefined() {
    docker:machine:host:existsWith --filter name=$(docker:machine:host:name)
}

docker:machine:host:isRunning() {
    docker:machine:host:existsWith --filter name=$(docker:machine:host:name) --filter state=Running
}

docker:machine:host:create() {
    if ! docker:machine:host:isDefined; then
        docker:machine create $(docker:machine:host:name) --driver virtualbox
    fi
}

docker:machine:host:start() {
    docker:machine:host:create
    if ! docker:machine:host:isRunning; then
        docker:machine start $(docker:machine:host:name)
    fi
}

docker:machine:host:stop() {
    if docker:machine:host:isRunning; then
        docker:machine stop $(docker:machine:host:name)
    fi
}

docker:machine:host:delete() {
    if docker:machine:host:isDefined; then
        docker:machine:host:stop
        docker:machine rm -y $(docker:machine:host:name)
    else
        log:warn "Could not delete machine as it did not exist"
    fi
}

docker:machine:connectClient() {
    eval $(docker:machine env "$(docker:machine:host:name)")
}

docker:install() {
    if bash:command:doesNotExist docker; then
        log:info "Installing docker..."
        brew:cask:install docker
    fi
}

docker:cli() { local args=$@
    brew:cask:install docker-toolbox
    docker:machine:host:create
    docker:machine:connectClient
    docker ${args}
}

docker:build() { local args=$@
    docker:cli build ${args}
}

docker:buildAndTag() { local name=$1; local tag=$2; local dockerfilePath=$3; local buildContextPath=$4;
    docker:build --tag "${name}:${tag}" -f "${dockerfilePath}" "${buildContextPath}"
}

docker:build:tag:forLocalDev() {
    echo "$(whoami)-$(date +%s)"
}

docker:run() { local imageName=$1; local tag=$2; local args=${@:3}
    docker:cli run "${imageName}:${tag}" ${args}
}

bash:runInBackground() { local logFile=$1; local command=${@:2}; export clearLogs
    log:info "Running ${command} in background. Logs written to ${logFile}..."
    if string:notEmpty "${clearLogs}"; then
        rm "${logFile}"
    fi
     $command >> "${logFile}" 2>&1 &
}

dev:environment:start() {
    retry:until:command:isSuccessful 30 3 minikube:dashboard
    minikube:devEnvironment:deploy
    dev:browser:open:fromMinikube
}

dev:environment:stop() {
    minikube:stop
}

dev:environment:restart() {
    dev:environment:stop
    dev:environment:start
}

dev:environment:docker:baseImage() {
    echo "node:9-slim"
}

dev:environment:bash() {
    dev:environment:docker:run:mounted -it "$(dev:environment:docker:baseImage)" /bin/bash
}

dev:environment:docker:run:mounted() { local args=$@
    docker:cli run -v "$(pwd)":/react-express-typescript -w /react-express-typescript ${args}
}

dev:environment:tscWatch() {
    dev:environment:docker:run:mounted "$(dev:environment:docker:baseImage)" npm run tscWatch
}

dev:environment:webpackWatch() {
    dev:environment:docker:run:mounted "$(dev:environment:docker:baseImage)" npm run webpackWatch
}

dev:environment:express:run() {
    dev:environment:docker:run:mounted -p 3000:3000 "$(dev:environment:docker:baseImage)" npm start
}

docker:machine:ip() {
    docker:machine inspect --format='{{.Driver.IPAddress}}' "$(docker:machine:host:name)"
}

retry:until:returnsNonEmptyString() { local numberOfTimes=$1; local secondsBetweenTries=$2; local command=${@:3}
    local timesRemaining=$numberOfTimes
    local conditionMet=false
    until strings:areEqual $conditionMet true; do
        local output=$($command)
        if string:notEmpty $output; then
            conditionMet=true
        else
            sleep ${secondsBetweenTries}
            timesRemaining=$(($timesRemaining - 1))
            if [ "$timesRemaining" -eq 0 ]; then
                log:error "$numberOfTimes retries exceeded in function retry:until:returnsNonEmptyString for command: ${command}"
                exit 1
            fi
        fi
    done
    echo $output
}

strings:areEqual() { local s1=$1; local s2=$2
    [ "${s1}" == "${s2}" ]
}

emptyStringIfCommandFails() { local command=$@
    eval $command > /dev/null 2>&1
    if strings:areEqual $? '0'; then
        echo "success"
    else 
        echo ""
    fi
}

retry:until:command:isSuccessful() { local numberOfTimes=$1; local secondsBetweenTries=$2; local command=${@:3}
    retry:until:returnsNonEmptyString $numberOfTimes $secondsBetweenTries emptyStringIfCommandFails $command
}

command:returnsNonEmptyString() { local command=$@
    string:notEmpty $($command)
}

command:isSuccessful() { local command=$@
    eval $command
}

dev:browser:open() {
    local host="$(retry:until:returnsNonEmptyString 20 1 docker:machine:ip)"
    local siteURL="http://${host}:3000"
    dev:environment:docker:run:mounted $(dev:environment:docker:baseImage) ./ci retry:until:command:isSuccessful 20 1 curl ${siteURL}
    open $siteURL
}

ci:functions:list() {
    typeset -f | awk '/ \(\) $/ && !/^main / {print $1}' | sort | grep ":" | grep -v "private:"
}

ci:help() { local commandGrepFilter=$1
    log:info ""
    log:info "Usage: ./ci {command} [options]"
    log:info ""
    log:info "Commands: "
    log:info ""
    if string:isEmpty $commandGrepFilter; then
        ci:functions:list
    else
        ci:functions:list | grep $commandGrepFilter
        if [ $? != "0" ]; then
            ci:functions:list
        fi
    fi
    log:info ""
}

ci:main() {
    if string:notEmpty $1; then
        if bash:command:exists $1; then
            $1 ${@:2}
        else
            log:error "Command ${1} does not exist..."
            ci:help $1
            exit 1
        fi
    else
        ci:help
    fi
}

#asdf:isNotInstalled() {
#    bash:command:doesNotExist asdf
#}
#
#asdf:install:asdfItself() {
#    if asdf:isNotInstalled; then
#        brew:install asdf
#    fi
#}
#
#asdf:plugin-add() { local packageName=$1
#    asdf:install:asdfItself
#    asdf plugin-add ${packageName}
#}

minikube:install:latestVersion() {
#    asdf:plugin-add minikube
    if bash:command:doesNotExist minikube; then
        brew:cask:install minikube
    fi
}

project:rootDirectory() {
    pwd
}

minikube:start() {
    if minikube:isNotRunning; then
        minikube:cli start --mount --mount-string="$(project:rootDirectory):/dev-environment" --memory 8192 --cpus 2
    fi
}

minikube:stop() {
    minikube:cli stop
}

minikube:delete() {
    minikube:cli delete
}

minikube:restart() {
    minikube:stop
    minikube:start
}

minikube:cli() { local args=$@
    minikube:install:latestVersion
    minikube ${args}
}

minikube:isNotRunning() {
    ! (minikube:cli status | grep "minikube: Running")
}

minikube:devEnvironment:deploy() {
    kubectl:cli apply -f src/devEnvironment/devEnvironment.yml
    helm:install:nginx:ingress:controller
}

kubectl:cli() { local args=$@
    minikube:start
    kubectl ${args}
}

docker:cli:forMinikube() { local args=$@
    minikube:start
    eval $(minikube docker-env)
    docker ${args}
}

minikube:dashboard() {
    minikube:cli dashboard
}

minikube:ssh() {
    minikube:cli ssh
}

minikube:ip() {
    minikube:cli ip
}

dev:browser:open:fromMinikube() {
    open "http://$(minikube:ip)"
}

helm:upgradeOrInstall() { local args=$@
    helm:cli upgrade --install ${args}
}

helm:install() { local args=$@
    helm:cli install ${args}
}

helm:cli() { local args=$@
    helm:install:helmItself
    minikube:start
    helm init
    log:info "Waiting 10 seconds after helm init..."
    sleep 10
    #TODO: ensure tiller is ready and working before running
    helm ${args}
}

helm:isNotInstalled() {
    bash:command:doesNotExist helm
}

helm:install:helmItself() {
    if helm:isNotInstalled; then
        brew:install kubernetes-helm
    fi
}

helm:nginx:ingress:controller:release:name() {
    echo "my-nginx"
}

helm:install:nginx:ingress:controller() {
    minikube:cli addons enable ingress
    if helm:nginx:ingress:controller:isNotInstalled; then
        helm:install stable/nginx-ingress --name $(helm:nginx:ingress:controller:release:name)
    fi
}

helm:nginx:ingress:controller:isNotInstalled() {
    ! helm:get $(helm:nginx:ingress:controller:release:name)
}

helm:get() { local chartName=$1
    helm:cli get ${chartName}
}

minikube:webpack:restart() {
    #TODO: Warn if it is not already running
    kubectl:cli delete pod -l app=dev-compile
}

git:generateSSHKeyPair() { local email=$1
    ssh-keygen -t rsa -b 4096 -C "${email}"
    eval "$(ssh-agent -s)"
    ssh:configure
    ssh-add -K ~/.ssh/id_rsa
    pbcopy < ~/.ssh/id_rsa.pub
    log:info "Your SSH public key has been copied to the clipboard, you may add it to github.com"
}

ssh:configure() {
    cat > ~/.ssh/config << EOF
    Host *
     AddKeysToAgent yes
     UseKeychain yes
     IdentityFile ~/.ssh/id_rsa
EOF
}

ci:main $@